<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>code学习日记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/css/mdui.min.css">
    <link rel="stylesheet" href="media/css/post.css">
    <link rel="stylesheet" href="media/live2d/css/live2d.css" />
    
</head>
<body class=" mdui-appbar-with-toolbar  mdui-theme-primary-pink mdui-theme-accent-pink">
<header class="mdui-toolbar mdui-color-pink mdui-appbar-fixed mdui-appbar-scroll-toolbar-hide" style="z-index: 1000">
    <a href="javascript:;" mdui-drawer="{target: '#left-drawer',overlay:true}" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
    <span class="mdui-typo-title">code学习日记</span>
    <div class="mdui-toolbar-spacer"></div>
<!--    <a href="javascript:history.go(0);" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
    <a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">more_vert</i></a>
</header>

<div class="mdui-drawer mdui-color-white mdui-drawer-full-height mdui-drawer-close" id="left-drawer">
    <ul class="mdui-list">
        <li class="mdui-subheader">菜单</li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/" class="mdui-list-item-content">首页</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/archives" class="mdui-list-item-content">归档</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/tags" class="mdui-list-item-content">标签</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="/post/about" class="mdui-list-item-content">关于</a>
        </li>
        
    </ul>
</div>

<div id="content" class="site-content">
    <div id="primary" class="content-area">
        <main id="main" class="site-main" role="main">
            <article id="post-1270" class="post-1270 post type-post status-publish format-standard hentry category-90 category-129 tag-149">
                <header class="entry-header">
                    <h1 class="entry-title">线段树</h1>
                    <p class="entry-census">发布于 2021-08-12</p>
                    <hr>
                </header>
                <div class="neko">
                    <h2>一、线段树概述</h2>
<p>对于一个数组（很大很大），有以下两个操作：</p>
<p>1.改变其中的某一个值arr[i]（update）</p>
<p>2.求出其中某个子区间[n,m]内的所有元素的和（query）</p>
<p>对于一般数组来说，操作1时间复杂度是O(1)，而操作2则需要O(n)。而如果我们在开一个数组，用于保存从头开始到第i个元素的和，那么我们求操作2只需要sum[m]-sum[n-1]便可，时间复杂度变成了O(1)，但这时候我们想要修改一个值就麻烦了，因为对于原数组来说很简单，但是sum数组就需要从i改到最后，操作1的时间复杂度反而变成了O(n)</p>
<p>线段树的作用就是把这个数组划分为两个区间，分别存放在左子树和右子树中，树上的每个节点的值即该区间中所有值的和，可以以下图为参考。<img src="https://chaosabyssf.github.io/post-images/1628739985870.PNG" alt="" loading="lazy"><img src="G:%5C%E5%8D%9A%E5%AE%A2%5C%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E5%BA%93%5C5.PNG" alt="5" loading="lazy"></p>
<p>这样就可以对操作1和操作2进行一个平均，使得两者的时间复杂度都变成了O(logn)</p>
<h2>二、代码实现</h2>
<pre><code class="language-c++">//首先是建树，注意node是每次查找时的根节点，不要和arr数组的搞混了
void Create_Tree(int arr[],int tree[],int left,int right,int node){
    if(right==left){
        tree[node]=arr[right];//或者left
        return;
    }
    int mid=(left+right)/2;
    int left_node=node*2+1;//左孩子的编号（参考树的性质）
    int right_node=node*2+2;//右孩子的编号
	Create_Tree(arr,tree,left,mid,left_node);//创建左子树
    Create_Tree(arr,tree,mid+1,right,right_node);//创建右子树
    tree[node]=tree[left_node]+tree[right_node];//赋值，值等于左子树+右子树的范围的和
}
</code></pre>
<p><img src="https://chaosabyssf.github.io/post-images/1628739976629.PNG" alt="" loading="lazy"><img src="G:%5C%E5%8D%9A%E5%AE%A2%5C%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E5%BA%93%5C6.PNG" alt="6" loading="lazy"></p>
<p>构建如上图表示的树（没有的节点用0填充，这点在初始化tree数组的时候有所体现）</p>
<p><strong>操作1：</strong></p>
<pre><code class="language-c++">//操作1和建树差不多，主要添加了需要更改的值：把arr[ind]的值改为val
void Update(int arr[],int tree[],int left,int right,int node,int ind,int val){
    if(right==left){//锁定了
        tree[node]=val;
        arr[ind]=val;
        return;
	}
    int mid=(left+right)/2;
    int left_node=node*2+1;//左孩子的编号（参考树的性质）
    int right_node=node*2+2;//右孩子的编号
    if(ind&gt;=left&amp;&amp;ind&lt;=mid)//ind在左子树，即[left,mid]的区间内
		Update(arr,tree,left,mid,left_node,ind,val);//从左子树中找
    else if(ind&gt;=mid+1&amp;&amp;ind&lt;=right)//ind在右子树
   	 	Update(arr,tree,mid+1,right,right_node，ind,val);//在右子树中找
    tree[node]=tree[left_node]+tree[right_node];//赋值，值等于左子树+右子树的范围的和
}
</code></pre>
<p><strong>操作2：</strong></p>
<pre><code class="language-c++">//求任意区间的和，也就是要找到这个区间内的所有元素，既然我们已经知道了一些区间的和，那么我们就可以分成两种情况
//情况1：当前区间是目标区间的子区间，那很简单了，直接取树节点的值
//情况2：当前与目标区间相交，这也要分两种情况，代码中会写到
int Query(int arr[],int tree[],int left,int right,int node, int target_left,int target_right){
    if(left==right){//找到叶子了，返回叶子的值
        return tree[node];
    }
    else if(left&gt;=target_left&amp;&amp;right&lt;=target_right){//是子区间，就不用向下找了，直接返回他们的和
        return tree[node];
    }
    else if(right&lt;target_left||left&gt;target_right){//找歪了，返回0
       	return 0;
    }
    int mid=(left+right)/2;
    int left_node=node*2+1;
    int right_node=node*2+2;
    int left_value=Query(arr,tree,left,mid,left_node,target_left,target_right);
    int right_value=Query(arr,tree,mid+1,right,right_node,target_left,target_right);
    return left_value+right_value;
}
//那有了相离，内含，相交怎么办？
//最后几行代码就是处理相交的问题：把相交的区间分为左区间和右区间，继续找——直到出现相离或内涵（顶多找到叶子节点，也就是第一个if）
</code></pre>
<p><strong>完整代码：</strong></p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAX 10000
typedef long long ll;
void Create_Tree(int arr[], int tree[], int left, int right, int node) {
    if (right == left) {
        tree[node] = arr[right];//或者left
        return;
    }
    int mid = (left + right) / 2;
    int left_node = node * 2 + 1;//左孩子的编号（参考树的性质）
    int right_node = node * 2 + 2;//右孩子的编号
    Create_Tree(arr, tree, left, mid, left_node);//创建左子树
    Create_Tree(arr, tree, mid + 1, right, right_node);//创建右子树
    tree[node] = tree[left_node] + tree[right_node];//赋值，值等于左子树+右子树的范围的和
}
void Update(int arr[], int tree[], int left, int right, int node, int ind, int val) {
    if (right == left) {//锁定了
        tree[node] = val;
        arr[ind] = val;
        return;
    }
    int mid = (left + right) / 2;
    int left_node = node * 2 + 1;//左孩子的编号（参考树的性质）
    int right_node = node * 2 + 2;//右孩子的编号
    if (ind &gt;= left &amp;&amp; ind &lt;= mid)//ind在左子树，即[left,mid]的区间内
        Update(arr, tree, left, mid, left_node,ind,val);//从左子树中找
    else if (ind &gt;= mid + 1 &amp;&amp; ind &lt;= right)//ind在右子树
        Update(arr, tree, mid + 1, right, right_node,ind,val);//在右子树中找
    tree[node] = tree[left_node] + tree[right_node];//赋值，值等于左子树+右子树的范围的和
}
int Query(int arr[], int tree[], int left, int right, int node, int target_left, int target_right) {
    if (left == right) {//找到叶子了，返回叶子的值
        return tree[node];
    }
    else if (left &gt;= target_left &amp;&amp; right &lt;= target_right) {//是子区间，就不用向下找了，直接返回他们的和
        return tree[node];
    }
    else if (right&lt;target_left || left&gt;target_right) {//找歪了，返回0
        return 0;
    }
    int mid = (left + right) / 2;
    int left_node = node * 2 + 1;
    int right_node = node * 2 + 2;
    int left_value = Query(arr, tree, left, mid, left_node, target_left, target_right);
    int right_value = Query(arr, tree, mid + 1, right, right_node, target_left, target_right);
    return left_value + right_value;
}
int main()
{
	ios::sync_with_stdio(false);
	int arr[] = { 1,3,5,7,9,11 };
	int size = 6;
	int tree[MAX] = { 0 };
    Create_Tree(arr, tree, 0, size - 1, 0);
    for (int i = 0; i &lt; 15; ++i)
        cout &lt;&lt; &quot;tree[&quot;&lt;&lt;i&lt;&lt;&quot;] = &quot;&lt;&lt;tree[i] &lt;&lt; endl;
    cout &lt;&lt; endl &lt;&lt; endl;
    Update(arr, tree, 0, size - 1, 0, 4, 6);
    for (int i = 0; i &lt; 15; ++i)
        cout &lt;&lt; &quot;tree[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; tree[i] &lt;&lt; endl;
    cout &lt;&lt; endl &lt;&lt; endl;
    cout&lt;&lt;Query(arr, tree, 0, size - 1, 0, 2, 5);
	return 0;
}
</code></pre>

                </div>
            </article>
        </main>
    </div>
    <div class="doc-footer-nav mdui-color-theme">
        <div class="mdui-container">
            <div class="mdui-row">
                
                <div class="mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left"></div>
                
                
                <div class="mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left"></div>
                
            </div>
        </div>
    </div>
    <br>
    
    <div class="comment"></div>
</div>
<footer class="mdui-container footer ">
    <div class="head_card-offset"></div>
    <div class="mdui-row mdui-row-gapless">
        <div class="k-container">
            <img width="100%" src="/media/img/skirt.png">
        </div>
    </div>

    <div class="site-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
</footer>
<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>
<!--<script src="/media/js/jquery-3.3.1.min.js"></script>-->
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/js/message.js"></script>

</body>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.3/js/mdui.min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    $('.comment').bind('DOMNodeInserted',()=>{
        $('.comment').unbind()

        $('.vbtn').addClass(' mdui-btn mdui-color-theme-accent mdui-ripple')
    })

    let valine = new Valine({
        el: '.comment',
        
        
        
        path: window.location.pathname,
        pageSize: 30,
        avatar:'mm',
        notify:true
    })
</script>
</html>
